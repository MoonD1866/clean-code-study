# 11장 시스템
## 시스템 제작과 시스템 사용을 분리하라
- 제작은 사용과 아주 다름
> **관심사**: 하나의 모듈이 수행하고자 하는 목적
- 시작 단계는 모든 애플리케이션이 풀어야할 관심사
- 관심사 분리는 중요한 설계 기법
- 하지만 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않음
  - ex) 초기화 지연, 계산 지연

### 시스템 생성과 시스템 사용을 분리하는 방법

#### Main 분리
- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮김

##### 특징
- 제어 흐름은 따라가기 쉬움
- main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘김
- 애플리케이션은 그저 객체를 사용할 뿐
- 애플리케이션은 main 이나 객체가 생성되는 과정을 전혀 모름

#### 팩토리
##### 특징
- 객체를 생성하는 시점은 애플리케이션이 결정
- 객체를 생성하는 코드는 애플리케이션이 모름
- 애플리케이션은 객체가 생성되는 구체적인 방법을 모름
- 필요하다면 애플리케이션에서만 사용하는 생성자 인수도 넘길 수 있음

#### 의존성 주입(Dependency Injection, DI)
- 제어 역전 (iversion of Contro, loC) 기법을 의존성 관리에 적용한 메커니즘
- 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘김
- 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임원칙(SRP)을 지키게 됨
- 책임질 메커니즘으로 'main' 루틴이나 특수 컨테이너를 사용
- 클래스가 의존성을 해결하려 시도하지 않음
- 클래스는 완전히 수동적
- 대신에 의존성을 주입하는 방법으로 설정자 Seter 메서드나 생성자 인수를 ( 혹은 둘 다를 ) 제공
- 스프링 프레임워크는 가장 널리 알려진 자바 DI 컨테이너를 제공

## 확장
- '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신
- 오늘은 주어진 사용자 스토리에 맞춰 시스템을 구현
- 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장
- 반복적이고 점진적인 애자일 방식의 핵심
![에자일 이미지]()
- 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있음
### EJB(관심사를 적절히 분리하지 못한 아키텍처 예)

- 비즈니스 논리는 EJB2 애플리케이션 '컨테이너' 에 강하게 결합
- 클래스를 생성할 때는 컨테이너에서 파생해야 함
- 테이너가 요구하는 다양한 생명주기 메서드도 제공해야 함 <br>

-> <br>

- 비즈니스 논리가 덩치 큰 컨테이너와 밀접하게 결합된 탓에 독자적인 단위 테스트가 어려움
- 컨테이너를 흉내 내거나 아니면 많은 시간을 낭비하며 EJB 와 테스트를 실제 서버에 배치해야 한
- 결국 객체 지향 프로그래밍이라는 개념조차 뿌리가 흔들림

### 횡단(cross-cutting) 관심사
- EJB2 아키텍처는 일부 영역에서 관심사를 거의 완벽하게 분리
- 트랜잭션 , 보안 , 일부 영속적인 동작은 소스 코드가 아니라 배치 기술자에서 정의
> 배치 기술자(Deployment Descriptor, DD): 애플리케이션의 설정 및 동작을 정의하는 XML 파일
- 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상 가능
- 하지만 현실적으로는 영속성 방식을 구현한 코드가 온갖 객체로 흩어짐 -> 횡단 관심사라는 용어가 나옴
- AOP 는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론

#### AOP
- 관점(aspect) 이라는 모듈 구성 개념은 " 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다" 라고 명시


### 자바 프록시
- 단순한 상황에 적합
- 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예
- JDK 에서 제공하는 동적 프록시는 인터페이스만 지원

#### 단점
- 코드가 상당히 많으며 제법 복잡
-  프록시를 사용하면 깨끗한 코드를 작성하기 어려움
- 스템 단위로 실행 ' 지점' 을 명시하는 메커니즘도 제공하지 않음

### 순수 자바 AOP 프레임워크
- 대부분의 프록시 코드는 판박이라 도구로 자동화할 수 있음
- 스프링 AOP,JBOSS AOP 등과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용
- 스프링은 비즈니스 논리를 POJO 로 구현
- POJO 는 순수하게 도메인에 초점을 맞춤
- POJO 는 엔터프라이즈 프레임워크에 ( 그리고 다른 도메인에도 ) 의존하지 않음   
-> 테스트가 개념적으로 더 쉽고 간단

#### 설정 파일을 사용한 애플리케이션 기반 구조
- XML 은 장황하고 읽기 어렵다는 문제가 있음
- 하지만 설정 파일에 명시된 '정책'이 겉으로 보이지 않지만 자동으로 생성되는 프록시나 관점 논리보다는 단순
- 일부 상세한 엔티티 정보는 애너테이션에 포함되어 그대로 남아있지만, 모든 정보가 애너테이션 속에 있으므로 코드 자체는 깔끔하고 깨끗

## 테스트 주도 시스템 아키텍처 구축
- 플리케이션 도메인 논리를 POJO 로 작성할 수 있다면, 즉 코드 수준에서아키텍처 관심사를 분리할 수 있다면 정한 테스트 주도 아키텍처 구축이 가능 <br>
-> 그때그때 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍처로 키워갈 수도 있음
- BDUF(Big Design up Front)를 추구할 필요가 없음
  - 처음에 쏟아 부은 노력을 버리지 않으려는 심리적 저항으로 인해, 그리고 처음 선택한 아키텍처가 향후 사고 방식에 미치는 영향으로 인해, 변경을 쉽사리 수용하지 못하는 탓

- 아주 단순하면서도 ' 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가는 것이 좋음

- 프로젝트를 시작할 때는 일반적인 범위 , 목표 , 일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 필요는 있음

## 시스템은 도메인 특화 언어가 필요하다
### DSL(Domain-Specife Language)
- DSL로 짠 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽힘
- 좋은 DSL 은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통간극을 줄여줌
- 도메인 전문가가 사용하는 언어로 도메인 논리를 구현하면 도메인을 잘못 구현할 가능성이 줄어듬
- 효과적으로 사용한다면 DSL 은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올림 -> 발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있음