# 13장 동시성
## 필요한 이유
소프트웨어에서 여러 작업을 동시에 수행할 수 있도록 하여 응답성 개선과 성능 향상
- 응답성 향상: UI 스레드와 백그라운드 작업을 분리하여 애플리케이션이 멈추지 않도록 함.
- 처리량 증가: 멀티코어 시스템에서 여러 작업을 병렬로 실행하여 성능을 극대화.
- 모듈화 개선: 독립적인 작업 단위로 나누어 코드 유지보수를 쉽게 함.

## 난관
- 경쟁 조건(Race Condition): 여러 스레드가 공유 자원에 동시에 접근할 때 발생하는 충돌.
- 데드락(Deadlock): 서로 다른 스레드가 서로의 자원을 기다리며 영원히 멈추는 상태.
- 라이브락(Livelock): 스레드들이 서로 실행을 양보하면서 끝없는 루프에 빠지는 현상.
- 성능 저하: 동기화 비용이 크거나, 과도한 컨텍스트 스위칭이 발생할 경우 오히려 성능이 나빠질 수 있음.
- 디버깅 어려움: 실행 순서가 일정하지 않아 버그 재현이 어렵고 예측이 힘듦.

## 동시성 방어 원칙
> - 단일 책임 원칙(Single Responsibility Principle)<br>
하나의 클래스/모듈이 동시성과 관련된 로직과 다른 로직을 동시에 처리하지 않도록 함.<br>
동시성 관리와 핵심 비즈니스 로직을 분리하여 유지보수를 용이하게 해야 함.

> - 자료 범위 제한(Limit the Scope of Data)<br>
공유 자원을 최소화하고, 가능하면 **지역 변수(Local Variable)**로 관리.

> - 자료 사본 이용(Copy the Data)<br>
공유 데이터를 직접 수정하는 대신, 복사본을 만들어 사용하여 충돌 위험을 줄임.

> - 독립적인 스레드 구현(Design Independent Threads)<br>
스레드 간의 의존성을 줄이고 각 스레드가 독립적으로 실행되도록 설계.<br>
메시지 패싱(Message Passing) 기법을 활용하여 공유 자원 접근을 최소화.

## 라이브러리를 이해하라
Java의 java.util.concurrent 패키지 활용

> - ExecutorService: 스레드 풀 관리
> - ConcurrentHashMap, CopyOnWriteArrayList: 스레드 안전한 컬렉션
> - Semaphore, CountDownLatch, CyclicBarrier: 스레드 동기화 도구

## 이해
### 실행 모델에 대한 이해
> - 스레드 풀(Thread Pool)과 작업 큐(Task Queue) 개념 이해
> - 스레드 스케줄링 및 컨텍스트 스위칭이 성능에 미치는 영향 고려
> - 비동기 프로그래밍 모델(Future, CompletableFuture 등) 학습
### 동기화하는 메서드 사이의 의존성 이해
> - 여러 개의 동기화된 메서드가 서로 의존적일 경우, 실행 순서에 따라 교착 상태(Deadlock)가 발생할 수 있음.
> - 동기화된 블록을 최소화하고, 가능하면 스레드 간 공유 데이터를 피하는 설계가 중요.
## 스레드 코드 테스트
+ 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
+ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
+ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
+ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
+ 프로세서 수보다 많은 스레드를 돌려보라
+ 다른 플랫폼에서 돌려보라
+ 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라