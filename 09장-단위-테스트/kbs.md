# Chapter 9: 단위 테스트

## 1. 단위 테스트의 중요성

### **단위 테스트란?**  
단위 테스트는 코드의 작은 부분을 독립적으로 테스트하는 작업이다.<br>
이를 통해 코드가 의도한 대로 동작하는지 확인할 수 있다.<br>
단위 테스트는 버그를 사전에 방지하고, 리팩토링 시 기존 기능의 안정성 보장

### **단위 테스트의 장점**  
단위 테스트는 코드의 신뢰성을 높이고, 변경 시 발생할 수 있는 오류를 사전에 예방할 수 있다.<br>
또한 테스트 코드는 코드의 문서 역할을 하며, 기능을 이해하는 데 도움이 된다.<br>
반복 가능한 테스트로 인해 코드 수정과 유지보수가 용이

## 2. 좋은 단위 테스트의 특징

### **독립적이어야 한다**  
각 단위 테스트는 다른 테스트에 의존하지 않아야 한다.<br>
테스트가 독립적이면, 테스트 순서와 관계없이 항상 동일한 결과를 얻을 수 있다.<br>
이렇게 하면 하나의 테스트 실패가 다른 테스트에 영향을 미치지 않으며, 문제가 발생한 부분을 쉽게 추적할 수 있다.

### **명확한 목적을 가져야 한다**  
각 단위 테스트는 명확한 목표를 가지고 있어야 한다.<br>
테스트가 무엇을 검증하는지 명확히 알 수 있어야 하고, 실패했을 때 원인을 쉽게 추적할 수 있다.<br>
목표가 불명확한 테스트는 의미가 없고, 유지보수가 어렵다.

### **빠르게 실행되어야 한다**  
단위 테스트는 빠르게 실행되어야 하며, 테스트를 자주 실행하는 것이 중요하다.<br>
테스트가 느리면 자주 실행하지 않게 되고, 문제가 생겼을 때 빠르게 대응할 수 없다.<br>
따라서 테스트는 가능한 한 최소한의 시간 내에 실행되어야 한다.

### **단일 기능만 테스트해야 한다**  
하나의 단위 테스트는 한 가지 기능만 테스트해야 한다.<br>
여러 기능을 동시에 테스트하면, 테스트 실패 시 어떤 부분에서 문제가 발생했는지 파악하기 어려워진다.<br>
각 테스트는 하나의 관심사만 다루고, 해당 기능에 대한 독립적인 검증을 해야 한다.

## 3. 테스트 주도 개발(TDD)

### **TDD란?**
~~Test? Delete, Deploy!~~<br>
TDD는 먼저 테스트를 작성한 후, 테스트를 통과하는 코드를 작성하는 개발 방식이다.<br>
이 과정은 "Red-Green-Refactor" 사이클로 이루어진다:<br>
- **Red**: 테스트를 먼저 작성하고, 실패하는 테스트를 실행한다.
- **Green**: 실패한 테스트를 통과하도록 코드를 작성한다.
- **Refactor**: 코드를 개선하거나 리팩토링한다.

### **TDD의 장점**  
TDD는 코드의 품질을 높이고, 기능이 제대로 동작하는지 즉시 확인할 수 있는 장점이 있다.<br>
또한, TDD는 소프트웨어 설계를 개선하며, 테스트 코드가 문서화 역할을 하므로 기능 이해에 도움을 준다.<br>
리팩토링을 안전하게 할 수 있어, 시스템을 개선하면서도 기존 기능을 깨지 않게 된다.

## 4. 테스트 가능한 코드를 작성하라

### **의존성 주입**  
테스트 가능한 코드를 작성하려면 의존성 주입(Dependency Injection)을 활용해야 한다.<br>
외부 의존성을 객체 내부에 직접 생성하지 않고 외부에서 주입하여, 테스트 시 의존성을 쉽게 교체할 수 있다.<br>
이렇게 하면 테스트 코드에서 의존성을 쉽게 모킹(Mock)하거나 스텁(Stub)으로 대체할 수 있다.

### **부작용을 최소화하라**  
부작용이 있는 코드는 테스트하기 어렵다.<br>
테스트 중에 외부 시스템을 호출하거나 상태를 변경하는 등의 부작용을 피하고, 순수한 함수를 작성하는 것이 중요하다.<br>
부작용을 최소화하면, 테스트는 더 예측 가능하고 독립적으로 실행될 수 있다.

## 5. 테스트 코드 작성 시 주의 사항

### **테스트는 읽기 쉬워야 한다**  
테스트 코드도 생산 코드와 마찬가지로 가독성이 중요하다.<br>
테스트 코드의 목적과 검증하려는 내용을 쉽게 파악할 수 있어야 한다.<br>
읽기 어려운 테스트 코드는 유지보수를 어렵게 하고, 새로운 개발자가 이해하기 힘들다.

### **테스트 코드도 리팩토링하라**  
테스트 코드도 리팩토링이 필요하다.<br>
중복된 코드가 많거나, 지나치게 복잡한 테스트는 리팩토링하여 단순화해야 한다.<br>
리팩토링을 통해 테스트 코드는 유지보수하기 쉬운 구조로 바뀐다.

## 6. 경계 테스트와 외부 시스템 테스트

### **경계 테스트**  
경계 테스트는 외부 시스템이나 의존성을 다룰 때, 경계를 명확히 설정하여 테스트하는 방식이다.<br>
경계 클래스를 작성하여 외부 시스템의 의존성을 관리하고, 해당 경계를 통해 외부 시스템과의 상호작용을 테스트할 수 있다.<br>
이렇게 하면 외부 시스템의 변경에 영향을 덜 받게 된다.

### **외부 시스템 테스트**  
외부 시스템과의 연동이 필요한 경우, 실제 시스템과의 상호작용을 테스트해야 한다.<br>
그러나 외부 시스템이 불안정하거나 변경될 가능성이 있기 때문에, 테스트 환경을 격리하여 외부 시스템을 모킹하거나 스텁으로 대체하는 것이 좋다.<br>
이렇게 하면 실제 외부 시스템에 의존하지 않고 안정적인 테스트 환경을 구축할 수 있다.

## 7. 테스트 커버리지

### **테스트 커버리지란?**  
테스트 커버리지는 코드에서 테스트가 실행된 범위를 측정하는 지표이다.<br>
높은 테스트 커버리지는 코드의 많은 부분이 테스트되었음을 의미하지만, 테스트 커버리지가 높다고 해서 모든 버그를 잡을 수 있는 것은 아니다.<br>
커버리지가 높아도 중요한 부분이 빠져있을 수 있기 때문이다.

### **테스트 커버리지의 한계**  
테스트 커버리지는 코드의 품질을 보장하는 절대적인 지표는 아니다.<br>
높은 커버리지에도 불구하고, 테스트가 충분하지 않거나 중요한 테스트가 빠져 있을 수 있다.<br>
따라서 커버리지를 측정할 때는 핵심 로직과 중요한 경로가 테스트되었는지 확인하는 것이 중요하다.

## 8. 테스트 유지보수

### **테스트 코드의 유지보수**  
테스트 코드도 시간이 지남에 따라 유지보수가 필요하다.<br>
새로운 기능이 추가되거나, 기존 코드가 변경되면 테스트 코드도 그에 맞춰 업데이트해야 한다.<br>
테스트 코드를 최신 상태로 유지하면, 코드 변경 시 오류를 빠르게 찾아낼 수 있다.

### **테스트 코드의 중요성**  
테스트 코드가 잘 유지되면, 코드 품질을 지속적으로 보장할 수 있다.<br>
테스트 코드가 없으면, 변경사항에 대해 확신을 가지기 어려워지고, 시스템에 버그가 숨어있을 수 있다.<br>
따라서 테스트 코드를 꾸준히 관리하고, 필요 시 리팩토링하여 유지보수 가능한 상태로 만들어야 한다.
