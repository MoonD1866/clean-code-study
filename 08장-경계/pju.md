# 경계

소프트웨어 경계를 깔끔하게 처리하는 기법과 기교

## 1. 외부 코드 사용하기

- 패키지 제공자, 프레임워크 제공자는 적용성을 최대한 넓게 제공한다.
- 그 이유는 **더 많은 환경에서 돌아가야 더 많은 고객이 구매하기 때문**이다.
- 그러나 사용자는 **자신의 요구에 집중하는 인터페이스**를 원한다.

### 예: `java.util.Map`
- `Map`은 다양한 인터페이스로 수많은 기능을 제공한다.

#### ❌ 안 좋은 예 (`Map`을 직접 사용)
```java
Map<String, String> userInfo = new HashMap<>();
userInfo.put("name", "John");
userInfo.put("age", "30");
```

#### ✅ 좋은 예 (제네릭스 활용)
```java
Map<String, Integer> userAges = new HashMap<>();
userAges.put("John", 30);
userAges.put("Jane", 28);
```

- `Map` 클래스 혹은 유사한 경계 인터페이스를 여러 곳에 넘기지 마라!
- `Map` 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

---

## 2. 경계 살피고 익히기

- 우리가 사용할 **외부 코드를 테스트하는 것이 바람직**하다.
- **외부 코드를 익히기 어렵고**, **통합하기도 어렵다.**
- 두 가지를 동시에 하려면 더욱 어려워진다.

### 해결 방법: 학습 테스트
- 간단한 **테스트 케이스를 작성하여 외부 코드를 익힌다**.
- 학습 테스트: 프로그램에서 **사용하려는 방식대로 외부 API를 호출**한다.
- **통제된 환경에서 API를 정확히 이해하고 활용법을 익힌다.**



---

## 3. 학습 테스트는 공짜 이상

- 비용 없음
- 필요한 지식을 확보 가능
- API 이해도를 높여주는 정확한 실험
- 투자하는 노력보다 얻는 성과가 더 큼
- 새로운 버전이 우리 코드와 호환되지 않으면 학습 테스트가 밝혀냄

---

## 4. 아직 존재하지 않는 코드를 사용하기

- **아는 코드와 모르는 코드를 분리하는 경계**를 설정한다.
- 내가 바라는 인터페이스를 먼저 설계하면 다음과 같은 장점이 있다.
  - **인터페이스를 전적으로 통제 가능**
  - **코드 가독성이 높아짐**
  - **코드의 의도가 명확해짐**
  - **테스트가 쉬워짐**

```java
public interface PaymentGateway {
    void processPayment(double amount);
}

public class StripePaymentGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Stripe로 결제: " + amount + "원");
    }
}
```

---

## 5. 깨끗한 경계

- **경계에 위치하는 코드는 깔끔히 분리**한다.
- **기대치를 정의하는 테스트 케이스도 작성한다.**
- **외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.**

---

## 결론
- 외부 코드를 사용할 때는 **경계를 명확히 설정**하고, **직접적인 노출을 최소화**하자.
- 학습 테스트를 통해 **외부 API를 익히는 과정이 중요**하다.
- 경계를 명확히 설정하면 **코드 유지보수성과 확장성이 향상**된다.