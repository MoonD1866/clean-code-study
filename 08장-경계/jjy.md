# 경계

## 외부 코드 사용하기

&nbsp;
 외부 코드를 사용할 때는 두 가지의 이해관계의 충돌때문에 문제가 생길 소재가 많다. 
제공자가 적용성을 최대한 넓히려 한다는 점과 사용자는 자신의 요구에 집중하는 인터페이스를 바란다는 점이다.
<br>

&nbsp;
 책에서는 java.util.Map을 예로 든다. Map은 기능성과 유연성은 확실히 유용하지만 여러 위험성이 존재한다. 
예를 들어 Map 사용자라면 누구나 Map 내용을 지울 권한이 있다. 
즉, 사용자에게 필요하지 않은 기능까지 제공된다라는 문제을 가지고 있다. 
그리고 Map은 객체 유형을 제한하지 않는다. 
마음만 먹으면 사용자는 어떤 객체 유형도 추가할 수 있다. 
즉, Map이 반환하는 값을 올바른 유형으로 변환할 책임은 사용하는 클라이언트에 있다.
<br>

&nbsp;
 위와 같은 문제를 해결하는 한가지 방법은 제네릭스(Generics)을 사용하는 것이다. 
그러면 클라이언트가 사용해야하는 객체의 유형을 강제할 수 있다. 
하지만 이 방법은 사용자에세 필요하지 않은 기능까지 제공한다는 문제는 해결하지 못한다.
<br>

&nbsp;
 또한 위 방법은 Map 인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다. 
실제로 자바 5가 제네릭스를 지원하면서 Map 인터페이스가 바뀌었다. 
그로인해 제네릭스 사용을 금지하는 시스템도 존재한다고 한다.
<br>


```java
public class Sensors {
  private Map sensors = new HashMap();

  public Sensor getById(String id) {
    return (Sensor) sensors.get(id);
  }
// 이하 생략
}
```
&nbsp;
 위 코드와 같이 경계 인터페이스를 새로운 객체안으로 숨기면 많은 문제가 해결된다. 
Map 인터페이스가 변경되더라고 나머지 프로그램들은 영향을 받지 않고 해당 객체만 수정하면 된다. 
<br>

&nbsp;
 그리고 이 Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다.
그래서 코드는 이해하기는 쉽지만 오용하기는 어렵다.
결국 이 클래스는 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.
<br>

## 경계 살피고 익히기

&nbsp;
 때로는 우리 버그인지 라이브러리 버그인지 찾아내느라 오랜 디버깅으로 골치 앓기도 한다.
이를 해결하는데 간단한 테스트 케이스를 작성하며 외부 코드를 익히는 학습 테스트 방법을 사용하는 것이 좋다.
학습 테스트를 이용해서 얻은 지식을 독자적인 클래스로 캡슐화하게 되면 우리의 프로그램은 외부 코드의 경계 인터페이스를 몰라도 사용에 아무런 문제가 없게 된다.
<br>

## 학습 테스트는 공짜 이상이다
&nbsp;
 학습 테스트에는 드는 비용이 없다.
뿐만 아니라 필요한 지식만 확보하는 손쉬운 방법이다.
그리고 새 버전이 나오더라도 학습 테스트를 돌리면 차이를 쉽게 확인 가능하며, 패키지가 예상대로 도는지도 검증이 가능하다.
<br>

## 아직 존재하지 않는 코드를 사용하기
&nbsp;
 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.
아직 알려고 해도 알 수 없는 경우 API를 자체적으로 인터페이스로 정의한다면 여러 장점을 살릴 수 있다.
<br>

&nbsp;
 먼저 인터페이스를 전적으로 통제할 수 있다는 장점이 있다. 그러므로 코드 가독성도 높아지고 코드 의도도 분명해진다.
그 이후 실제 API를 적용할 때는 중간에 ADAPTER 패턴의 클래스를 사용하여 캡슐화해 API가 바뀔 때 수정할 코드를 한 곳으로 모을 수 있다.
<br>

&nbsp;
 테스트를 할 때는 Fake 클래스를 만들어 코드를 테스트 할수 도 있다.
<br>

## 깨끗한 경계

&nbsp;
 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않는다.
<br>

