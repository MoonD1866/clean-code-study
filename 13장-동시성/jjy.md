# 동시성

## 동시성이 필요한 이유

### 동시성
- 무엇과 언제를 분리하는 전략

### 미신과 오해
- 동시성은 항상 성능을 높여준다. X
  - 동시성은 때로 성능을 높여준다.

- 동시성을 구현해도 설계는 변하지 않는다. X

- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다. X
  - 실제로 콘테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.

### 동시성과 관련된 타당한 생각
- 동시성은 다소 부하를 유발한다.
- 동시성을 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

## 동시성 방어 원칙

### SRP
- 동시성 관련 코드는 다른 코드와 분리해야 한다

### 따름 정리(corollary): 자료 범위를 제한하라
- 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하는 것을 권장
- 자료를 캡슐화, 공유 자료를 최대한 줄임

### 따름 정리: 자료 사본을 사용하라
- 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성이 아주 낮아짐
- 복사에 비용이 들더라고 동기화를 피할 수 있다면 상쇄할 가능성이 큼

### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드를 구현
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장
- 독자적인 스레드로, 가능하다면 다른 프록세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할

## 라이브러리 이해하라
- 스레드 환경에 안전한 컬렉션을 사용
- executor 프레임워크 사용
- 가능하다면 스레드가 차단되지 않는 방법을 사용
- 일부 클래스 라이브러리는 스레드에 안전하지 못함

## 실행 모델을 이해하라

### 생산자 소비자
- 생산자 스레드는 정보를 생성해 버퍼나 대기열에 넣는다.
- 소비자 스레드는 대기열에 정보를 가져와 사용한다.
- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원
- 생산자는 대기열이 빈 공간이 있다는 소비자의 시그널을 받고 움지김
- 소비자는 생산자가 대기열에 정보가 있다는 시그널을 받아야 실행됨
- 잘못하면 생산자와 소비자 둘 다 진행 가능함에도 시그널을 기다리는 가능성 존재

### 읽기-쓰기
- 둘 사이에서 복잡한 균형잡기가 필요

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 메서들 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생김
- 메서드를 보호하는 synchronized라는 개념을 지원

## 동기화하는 부분을 작게 만들어라

## 올바른 종료 코드는 구현하기 어렵다
- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라

## 스레드 코드 테스트하기
- 프로그램 설정과 부하를 밖꿔가며 자주 돌려라
- 테스트가 실패하면 원인을 추적하라
- 다시 돌렸을 때 통과하더라도 그냥 넘어가지 마라

### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

### 다중 스레드를 쓰는 코드 부분을 다양한 환겨에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할수 있게 작성하라

### 프로세서 수보다 많은 스레드를 돌려보라

### 다른 플랫폼에서 돌려보라

### 코드에 보조 코드를 넣어 돌려라. 강제로 실페를 일으키게 해보라
- 직접 구현
- 도구를 사용하여 자동화
