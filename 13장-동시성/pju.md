# 동시성 (Concurrency)



## 동시성이 필요한 이유

- **동시성**은 결합을 없애는 전략이다.  
- 즉, **무엇**과 **언제**를 분리하는 전략이다.
- 웹 컨테이너가 제공하는 결합 분리 전략은 완벽과 거리가 멀다.

### 동시성이 필요한 예시

1. 다수의 사용자가 동시에 웹 서비스를 이용하는 경우
2. 대량의 데이터를 병렬로 처리해야 하는 경우
3. 사용자 요청과 데이터 저장을 동시에 처리해야 하는 경우

---

## 1. 동시성에 대한 오해

- 동시성은 주의하지 않으면 난감한 상황에 처하므로 어렵다.

### 일반적인 미신과 오해

- **동시성은 항상 성능을 높여준다**
  - 여러 프로세서가 동시에 처리할 독립적인 계산이 많을 때만 성능 향상이 가능하다.

- **동시성을 구현해도 설계는 변하지 않는다**
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 완전히 다르다.

- **웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요 없다**
  - 실제로는 컨테이너의 동작 방식, 동시 수정, 데드락 등을 이해해야 한다.

---

## 2. 동시성과 관련된 타당한 생각

- **동시성은 다소 부하를 유발한다**
  - 성능 부하 및 코드 복잡도 증가

- **동시성은 복잡하다**
  - 간단한 문제라도 동시성은 어렵다

- **동시성 버그는 재현하기 어렵다**
  - 일회성 문제로 간주되어 무시되기 쉽다

- **동시성 구현은 설계 전략의 재고를 요구한다**

---

## 3. 동시성을 구현하기 어려운 이유

### 예시: getNextId()

```java
class IdGenerator {
    int lastIdUsed = 42;

    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

- 두 스레드가 이 인스턴스를 공유하고 동시에 getNextId()를 호출한다고 가정하면 결과는 다음 셋 중 하나:

1. 한 스레드는 43, 다른 스레드는 44 → `lastIdUsed = 44`
2. 한 스레드는 44, 다른 스레드는 43 → `lastIdUsed = 44`
3. 둘 다 43 → `lastIdUsed = 43` (❗ 문제가 발생)

- 메서드 실행 경로는 최대 **12,870개**
- 변수를 `int` → `long`으로 바꾸면 조합은 **2,704,156개**
- 대부분은 올바르지만, **일부 경로가 잘못된 결과**를 낸다.

---

## 4. 동시성 방어 원칙

### 4-1. 단일 책임 원칙 (SRP)

- 메서드/클래스/컴포넌트는 변경 이유가 **하나**여야 한다.
- **동시성 코드**는 다른 로직과 **분리**되어야 한다.

### 고려할 점

- 동시성 코드는 독립적인 개발/변경/조율 주기를 가짐
- 구현이 어렵고 다양한 방식으로 실패할 수 있음
- **권장사항**: 동시성 코드는 다른 코드와 분리하라

---

### 4-2. 따름 정리: 자료 범위를 제한

- 처음부터 **공유하지 않도록 설계**하라.

### 4-3. 따름 정리: 스레드는 독립적으로 구현

- 각 스레드는 독자적으로 존재
  - 자료 공유 없음
  - 요청 하나만 처리
  - 모든 정보는 로컬 변수에 저장

- **권장사항**: 자료를 독립적인 단위로 분할하여, 다른 프로세서에서도 동작 가능하도록 하라

---

### 4-4. 라이브러리를 이해하기

- **스레드 안전한 컬렉션 사용**
- Executor 프레임워크로 병렬 작업 처리
- 가능하면 **비차단 방식** 사용
- 일부 라이브러리는 스레드 안전하지 않음

---

### 4-5. 스레드 안전한 컬렉션

- 자바 기준:
  - `java.util.concurrent`
  - `java.util.concurrent.atomic`
  - `java.util.concurrent.locks`

---

### 4-6. 실행 모델을 이해하라

- **한정된 자원**: 사용 가능한 리소스가 제한되어 경쟁 발생
- **상호 배제(Mutual Exclusion)**: 한 번에 하나의 스레드만 자원을 접근
- **기아(Starvation)**: 스레드가 자원 접근 기회를 계속 잃음
- **데드락(Deadlock)**: 서로 자원을 기다리며 멈춤
- **라이브락(Livelock)**: 계속 상태 변경하지만 진전 없음

---

### 4-7. 생산자-소비자

- 생산자 스레드는 대기열에 **빈 공간**이 있어야 정보 추가 가능
- 소비자 스레드는 **정보가 있어야** 가져올 수 있음
- 둘 다 **시그널을 기다리다 멈출 위험** 존재

---

### 4-8. 읽기-쓰기

- 읽기 스레드와 쓰기 스레드 요구를 균형 있게 처리
- 전략: 읽기 스레드가 없을 때만 쓰기 스레드 갱신 허용
  - 단점: 읽기 요청이 계속되면 쓰기 스레드는 **기아 상태**

---

### 4-9. 식사하는 철학자들 문제

- 철학자들은 양쪽 젓가락이 필요하지만,  
  모두가 동시에 들려고 하면 데드락 발생
- **기아**, **데드락**, **라이브락**을 현실적 예시로 설명 가능
  - 예: 누군가는 계속 밥을 못 먹는 상황

---

### 4-10. 동기화 메서드 간의 의존성

- **권장사항**: 공유 객체 하나엔 하나의 메서드만 사용

#### 여러 메서드가 필요할 경우

1. 클라이언트에서 잠금 처리
2. 서버에서 잠금 처리
3. 중간 계층(연결 서버)에서 잠금 처리

---

### 4-11. 동기화 범위 최소화

- **임계영역은 보호**해야 한다
- 하지만 **최대한 작게 유지**
- **권장사항**: 동기화 구문은 작고 간결하게

---

### 4-12. 올바른 종료 코드 구현

- 영구적 시스템과 일시적 시스템은 종료 전략이 다름
- 가장 흔한 문제: **데드락** → 시그널을 기다리며 영원히 멈춤

- **권장사항**: 종료 전략을 **초기 설계부터 고려**하고 구현하라

---

### 4-13. 스레드 코드 테스트

- 테스트는 완전하지 않지만, **위험을 줄일 수 있다**

#### 테스트 전략

1. 이상한 실패는 **스레드 문제로 의심**
2. **단일 스레드 환경** 먼저 완성
3. 스레드 코드를 **다양한 환경에 쉽게 삽입 가능**하도록 구현
4. 설정에 따라 스레드 수 등을 쉽게 조정 가능하도록
5. **프로세서 수보다 많은 스레드**로 테스트
6. **다른 플랫폼**에서도 테스트
7. **강제 실패 유도 코드** 삽입 → 버그 탐지

---

## ✅ 결론

- 동시성은 어렵고 위험하지만, 잘 다루면 강력한 도구이다.
- 철저한 설계, 테스트, 분리된 코드 구조가 필수적이다.
- 문제를 회피하지 말고 **초기부터 전략적으로 접근**하라.



---
## 💡 내 생각

동시성은 단순히 성능을 높이기 위한 기술이 아니라, 약간의 철학의 느낌을 받았다.
동시성에 대해 어렵고 복잡하게만 느껴지지만, 당장 완벽하게 이해하진 못하더라도, 계속 상기시키며 여러가지를 시도 해보면서 자연스럽게 실력을 키워야겠다.

실전에서 예상 못한 문제는 항상 터져왔었기에 운전과 비유하자면 방어운전이 나를 위한 또 타인을 위한 방식이듯이 코드도 **방어적으로 코드를 짜는 습관** 을 들여 팀 전체를 배려하는 코드가 될 수 있도록 공부 해야겠다...

---


